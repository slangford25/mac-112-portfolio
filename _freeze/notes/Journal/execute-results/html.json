{
  "hash": "a5e238624f0ee674d9d6ea8f1bd7e65e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Journal\"\n---\n\n\n\n\n\n# 3. Data Viz\n\nData Viz: displaying data in such a way that we can glean more information about the data, such as patterns, typical outcomes, and distribution.\n\n### Components of graphs:\n- frame (sets up the grid and axes)\n- layer (adds the geometric elements that make up the graph, called geom_ in ggplot)\n- scales (changes color/size/shape/etc)\n- faceting (splits up the data )\n- theme (finer scale adjustments like font size)\n\n### For one variable viz:\n- categorical: bar plot\n- numerical: histogram/density plot\n\nggplot syntax:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ___, aes(x = ___)) + \n  geom___(color = \"___\", fill = \"___\") + \n  labs(x = \"___\", y = \"___\")\n```\n:::\n\n\n\n\n\n### When discussing data visualizations, you typically look at:\n- typical outcome\n- variability + range\n- shape\n- outliers\n\n\n# 4. Bivariate Viz\n\nAnother way to look at the data is to look at relationships within the data. There are\n- Repsonse variables (dependent variables)\n- Predictors (independent variables)\n\n### What plots to use:\n- 2 quantitative: scatterplot\n- 2 categorical: stacked bar/facet wrapped bar plot\n- 1 quantitative, 1 categorical: violin plot, boxplot, stacked density plots.\n\n# 5. Multivariate Viz\n\nWhich chart to use:\n\n- 3 cat: bar (x, color, facet)\n- 2 cat, 1 num: histogram/density (color, facet, x), box, violin (x, facet, y)\n- 1 cat, 2 num: scatter (facet/color/shape, x, y), heatmap (y, x, shade), star (y, size, )\n- 3 num: scatter (x, y, size/shade)\n\n\n# 6. Spatial Viz\n\n- Point map: a map that specific locations are plotted on (ex: favorite places in the twin cities).\n- Contour map: plotting density/distribution on a map rather than individual points\n- Choropleth Maps: plotting outcomes in different regions (ex: percentage of democratic votes in each state)\n\nLeaflet: a package that can be used to make interactive maps, commonly point maps\ncommon functions for leaflet:\n\n- leaflet() (makes the leaflet)\n- addTiles() (makes the base map)\n- addMarkers()\n- addPolygons()\n- print() (need to print to see the leaflet)\n\nggplot is typically better for making chloropleth maps than leaflet.\n\n\n# 7. Effective Viz\n\nEffective visualizations are important in order to accurately portray your data in a way that people can understand. \n\nVisualizations can be good, ugly, bad, or wrong. \n\n- Good: viz is clear, easy to understand, accessible, and helpful.\n- Ugly: nothing is incorrect about the viz, but the overall aesthetic is ugly\n- Bad: the viz is “unclear, confusing, overly complicated, or deceiving”\n- Wrong: viz is incorrectly displaying the data and/or the trends\n\nIn order to have effective viz you need to:\n\n- have clear, concise titles/axes\n- include a figure caption\n- include an alt caption, for screen readers\n- avoid using overly similar colors whenever possible\n- add context\n- make data anonymous when possible\n\n\n# 8. Wrangling Verbs\n\ntidyverse has many helpful functions that allow us to wrangle the data into a way that we can meaningfully create data viz.\n\n99.99% of data will not be entirely clean and ready to use. You will have to clean and reformat the data in order to use it.\n\nSome key functions to use are: \n\n\n\n| verb        | action                                            |\n|:------------|:--------------------------------------------------|\n| `arrange`   | **arrange** the *rows* according to some *column* |\n| `filter`    | **filter** out or obtain a subset of the *rows*   |\n| `select`    | **select** a subset of *columns*                  |\n| `mutate`    | **mutate** or create a *column*                   |\n| `summarize` | calculate a numerical **summary** of a *column*   |\n| `group_by`  | **group** the *rows* by a specified *column*      |\n\n\n\n# 9. Wrangling + Dates\n\nOrder of the functions matter. If you want to arrange by one column but then only include 2 different columns in your final data frame, you need to do arrange first before selecting the columns or else you will get an error.\n\nKey syntax for filtering:\n\n| symbol           | meaning                   |\n|:-----------------|:--------------------------|\n| `==`               | equal to                  |\n| `!=`               | not equal to              |\n| `>`               | greater than              |\n| `>=`              | greater than or equal to  |\n| `<`               | less than                 |\n| `<=`              | less than or equal to     |\n| `%in% c(***, ***)` | a list of multiple values |\n\nsummarize ex:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> filter(species == “Chinstrap”) |> group_by(sex) |> summarize(min = min(body_mass_g), max = max(body_mass_g)) |> mutate(range = max - min)\n```\n:::\n\n\n\n\n\n# 10. Reshaping Data\n\nTwo kinds of reshaped data:\n\n- Aggregate: more general info about observations gained using functions like group_by() with summarize(), no info about individual observations\n- Raw data: original data that is just reshaped to be able to analyze.\n\n\nPivoting:\n\npivot wider: \"widens\" data by expanding two columns into multiple. One column provides the new column names and the other provides the values.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> \n  pivot_wider(names_from = col1, values_from = col2)\n```\n:::\n\n\n\n\n\n\npivot longer: \"lengthens\" the data by collapsing several columns into two. Column names move to a new names_to column and values to a new values_to column.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> \n  pivot_longer(cols = c(\"columns we want\"), names_to = \"name of new names column\", values_to = \"name of new values column\")\n```\n:::\n\n\n\n\n\n\n# 11. Joining Data\n\nJoining functions allow us to either filter one dataset based on another or to join two datasets togeher. There are two different types of joining functions:\n\n- mutating joins: left_join(), inner_join() and full_join()\n- filtering joins: semi_join(), anti_join()\n\n\nMutating Joins:\n\n> left_join: join two datasets together, keep all rows in the left dataset and add in matching columns from right dataset. Automatically uses a common column to join datasets, but you can specify which one/ones you want to use as the join key.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_data %>% \n  left_join(right_data, c(\"L_col\" = \"R_col\")) # indicating that those two are the join key\n```\n:::\n\n\n\n\n\n> inner_join: keeps only the columns that are in both the left and right datasets.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_data %>% \n  inner_join(right_data)\n```\n:::\n\n\n\n\n\n\n> full_join: keeps the columns in the right AND/OR the left datasets\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_data %>% \n  full_join(right_data)\n```\n:::\n\n\n\n\n\n\nFiltering Joins:\n\n> semi_join: keep all rows in left that match right\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_data %>% \n  semi_join(right_data)\n```\n:::\n\n\n\n\n\n> anti_join: keep all rows in left that do not match in right\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_data %>% \n  anti_join(right_data)\n```\n:::\n\n\n\n\n\n\n# 12. Factors\n\nWhen working with character strings, you can either use regex to wrangle them or convert them into factors.\n\nSome of the factor wrangling functions:\n\n-   functions for changing the **order** of factor levels\n    -   `fct_relevel()` = *manually* reorder levels\n    -   `fct_reorder()` = reorder levels according to values of another *variable*\n    -   `fct_infreq()` = order levels from highest to lowest frequency\n    -   `fct_rev()` = reverse the current order\n-   functions for changing the **labels** or values of factor levels\n    -   `fct_recode()` = *manually* change levels\n    -   `fct_lump()` = *group together* least common levels\n\n\n# 13. Strings\n\nCommon string modifying/locating functions:\n\n| function            | arguments                 | returns           |\n|:--------------------|:--------------------------|:------------------|\n| `str_replace()`     | `x, pattern, replacement` | a modified string |\n| `str_replace_all()` | `x, pattern, replacement` | a modified string |\n| `str_to_lower()`    | `x`                       | a modified string |\n| `str_sub()`         | `x, start, end`           | a modified string |\n| `str_length()`      | `x`                       | a number          |\n| `str_detect()`      | `x, pattern`              | TRUE/FALSE        |\n\nSummary of what each function does:\n\n- str_replace(x, pattern, replacement) finds the first part of x that matches the pattern and replaces it with replacement\n\n- str_replace_all(x, pattern, replacement) finds all instances in x that matches the pattern and replaces it with replacement\n\n- str_to_lower(x) converts all upper case letters in x to lower case\n\n- str_sub(x, start, end) only keeps a subset of characters in x, from start (a number indexing the first letter to keep) to end (a number indexing the last letter to keep)\n\n- str_length(x) records the number of characters in x\n\n- str_detect(x, pattern) is TRUE if x contains the given pattern and FALSE otherwise\n\n\n# 15. Data Import\n\nRather than using absolute filepaths that will not work on other people's computers, use relative filepaths\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimdb_temp <- read_csv(\"../data/imdb_5000_messy.csv\")\n\n#the .. means exit current folder\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}